//! \file analyze_LHE
//!
//! Code to read and analyze LHE files generated by Powheg/MadGraph
//! Fit for longitudinal polarization and FB asymmetry of lplm events
//! Do q-qbar and q-gluon cases


#include "compute_AFB.C"

// Global definitions 

struct particle {         //!< individual particle structure
    int id;                 //! pdg particle id
    int status;             //! decay status
    int mother[2];          //! particle mother indices
    int color[2];           //!< color info
    double p[5];            //! 4-vector + mass
    float vtime;            //! lifetime
    float spin;             //! spin (helicity) info
} ;

struct eventcm {          //!< useful info in various frames
    double coststar;        //! t-scattering angle
    double mtt;             //! invariant mass of ttbar pair
    double xF;              //! Feynman x of ttbar pair
} ;
Double_t get_AFB(char  infile[120], double m_low, double m_high, int correct_AFB_mbin = -1, bool print = false);
Double_t get_AFB(int Zp_mass, Double_t cpl, int m_bin, bool correct_AFB = false, bool print = false);

Double_t apply_AFB_correction(Double_t AFB, Double_t u_frac, int m_bin, bool print=false){
    //slopes and intercepts from fits (As a function of uquark frac
    Double_t m[6] = {0.296, 0.299, 0.341, 0.238, 0.278, 0.247};
    Double_t b[6] = {0.766, 0.764, 0.725, 0.807, 0.776, 0.801};
    //linear function to parameterize shift
    Double_t corr_factor = m[m_bin]*u_frac + b[m_bin];
    if(print) printf("Correcting AFB with a factor of %.2f \n", corr_factor);
    return corr_factor * AFB;
}

Double_t get_AFB(int Zp_mass, Double_t cpl, int m_bin, bool correct_AFB = false, bool print = false)
    //reweight PYTHIA samples to get AFB for given Zprime mass at a given
    //dilepton mass
{

    // Construct file name to analyze
    static char infile[80];

    //strcpy(infile, "Zprime_m200.lhe");
    Float_t m_bins[] = {150,200,   250,    350,    500,    700, 100000};
    const double m_low = m_bins[m_bin];
    const double m_high =m_bins[m_bin + 1];
    int run_num =m_bin +1;
    string base_dir("/uscms_data/d3/oamram/condor_jobs/Zp_jobs/condor_output");
    if(cpl< 0.99){
        //need to remove leading 0 in float
        unsigned int_cpl = (unsigned) 100 * (cpl + 0.005);
        sprintf(infile, (base_dir+"/Zp_M%i/Zp_events_M%i_kL.%2u_bin%i.lhe").c_str(), Zp_mass, Zp_mass, int_cpl, run_num);
    }
    //else if (cpl == 1.0){
        //sprintf(infile, (base_dir+"/Zp_M%i/Zp_events_M%i_kL%.1f_bin%i.lhe").c_str(), Zp_mass, Zp_mass, cpl, run_num);
    //}
    else sprintf(infile, (base_dir+"/Zp_M%i/Zp_M%i_kL%.2f_bin%i.lhe").c_str(), Zp_mass, Zp_mass, cpl, run_num);
    //sprintf(infile, "lhe_files/MG5_condor_files/Zp_events_M%i_bin%i.lhe", Zp_mass, run_num);
    //printf("Opening file %s \n", infile);
    //printf("M bins from %.0f to %.0f \n", m_low, m_high);

    int correct_AFB_mbin = -1; //-1 means don't do correction
    if(correct_AFB) correct_AFB_mbin = m_bin;

    return get_AFB(infile, m_low, m_high, correct_AFB_mbin, print);
}


Double_t get_AFB(char infile[120], double m_low, double m_high, int correct_AFB_mbin = -1, bool print = false){

    // Local variables 
    int i, j, k, iqk=0, iqb=0, itq=0, itb=0, ig1=0, ig2=0, ijt, njet=0, npflavor=0, nevent, nfit;
    int iqk_extra = 0, iqb_extra=0;
    int nqqb=0, ngg=0, itbq, itbb, itqk, itqb, itlp, itnu;
    int nup, idrup; 
    float xwgtup, scalup, aqedup, aqcdup;
    double alpha;
    static char header[80], inp1[80], outfile0[80], outfile1[80], outfile2[80];
    FILE *ifp;
    particle in;

    long deltas, deltaus;
    double deltat;


    // Make sure file is available 

    ifp = fopen(infile, "r");
    if (ifp==NULL) {
        printf("can't find %s\n",infile);
        return -1.;
    }

    //  Book Histograms

    gStyle->SetOptFit(101);
    gStyle->SetHistLineWidth(2);
    static vector<TH1F*> hp(12);

    double root2 = sqrt(2.);
    double Ebeam = 6500.;
    double Pbeam = sqrt(Ebeam*Ebeam - 0.938*0.938);

    nevent=0; nfit=0;
    int event_num =0;
    int nTotal =0;
    int nFail =0;
    Double_t nF = 0, nB = 0;
    Double_t n_utype=0, n_dtype=0;

    // Scan throught file first for the beginning of an event record	

    while (fscanf(ifp,"%s", inp1) !=EOF) {
        if(strcmp(inp1,"<event>") == 0) {
            event_num++;


            // event found


            // read event info

            fscanf(ifp,"%d %d %f %f %f %f", &nup, &idrup, &xwgtup, &scalup, &aqedup, &aqcdup);

            // Make a vector to hold all particles for each event

            std::vector<particle> up;

            iqk = -1; iqb = -1; itq = -1; itb = -1; ig1 = -1; ig2 = -1; ijt = -1;
            iqk_extra = -1;
            iqb_extra = -1; //in case event with 2 quarks or 2 anti quarks
            njet = 0; npflavor = 0; nqqb = 0; ngg = 0;
            int qtype = 0; // type of quark, uct = 0 , dsb = 1

            // Now loop over all particles

            for(i=0; i<nup; ++i) {
                fscanf(ifp,"%d %d %d %d %d %d %lf %lf %lf %lf %lf %f %f", &in.id, &in.status, &in.mother[0], &in.mother[1],
                        &in.color[0], &in.color[1], &in.p[0], &in.p[1], &in.p[2], &in.p[3], &in.p[4], &in.vtime, &in.spin);	
                up.push_back(in);
            } 

            //  Do event by event analysis here	

            // first, flag the stable final particles	   
            for(i=0; i<nup; ++i) {
                if(up[i].mother[0] == 0 && up[i].mother[1] == 0) {
                    if(up[i].id == 1 || (up[i].id == 2 || (up[i].id == 3 || (up[i].id == 4 || up[i].id == 5)))) {
                        if(iqk == -1) iqk = i; 
                        else{ 
                            iqk_extra = i;
                            //printf("Found double quark event \n");
                        }
                        continue;
                    }
                    if(up[i].id == -1 || (up[i].id == -2 || (up[i].id == -3|| (up[i].id == -4 || up[i].id == -5)))) {
                        if (iqb == -1) iqb = i; 
                        else{ 
                            iqb_extra = i;
                            //printf("Found double quark event \n");
                        }
                        continue;
                    }
                    if(ig1 == -1) {ig1 = i;} else {ig2 = i;}
                    continue;
                }
                if(up[i].id == 13) {itq = i; continue;}
                if(up[i].id == -13) {itb = i; continue;}

            }



            if(((iqk == -1) && (ig1 == -1 && iqb_extra == -1)) ||
                    ((iqb == -1) && (ig1 == -1 && iqk_extra ==-1)) ||
                    ((iqk == -1 && iqb == -1) && (ig2 == -1)) )   {
                printf("unable to determine initial state for event %i \n", event_num);
                printf("indices are %i %i %i %i \n", iqk, iqb, ig1, ig2);
                printf("printing particles \n");
                for(i=0; i<nup; i++){
                    printf("%d %d %d %d \n", up[i].id, up[i].status, up[i].mother[0], up[i].mother[1]);
                }
                nFail++;
                continue;
            }
            if(itq == -1 || itb == -1){
                printf("no mus \n");
                nFail++;
                continue;
            }

            if(abs(up[iqk].id) % 2 == 0) qtype = 0; //u-type quark
            else qtype = 1;
            //          if(njet < 1) continue;
            //          if(njet > 0) continue;
            //          if(njet < 1) continue;

            // Next build 4-vectors for all 6 particles

            TLorentzVector tq(up[itq].p[0], up[itq].p[1], up[itq].p[2], up[itq].p[3]);
            TLorentzVector tb(up[itb].p[0], up[itb].p[1], up[itb].p[2], up[itb].p[3]);
            TLorentzVector p1(0., 0., Pbeam, Ebeam);
            TLorentzVector p2(0., 0., -Pbeam, Ebeam);
            if(iqk > -1 && up[iqk].p[2] < 0.) {
                TLorentzVector p = p1;
                p1 = p2;
                p2 = p;
            }
            else {
                if(iqb > -1 && up[iqb].p[2] > 0.) {
                    TLorentzVector p = p1;
                    p1 = p2;
                    p2 = p;
                }
            }

            // Create vectors for the parents
            TLorentzVector cm = tq + tb;
            Double_t pt = cm.Pt();
            nTotal++;

            //printf("M is %.0f \n", cm.M());
            if(cm.M() >= m_low && cm.M() <= m_high){
                ++nevent;
                // Invariant mass of pair
                double mass = cm.M();

                double xF = 2.*cm.Pz()/13000.;

                // Boost everything into the t-tbar rest frame

                TVector3 beta = -cm.BoostVector();
                tq.Boost(beta);
                tb.Boost(beta);
                p1.Boost(beta);
                p2.Boost(beta);

                // Now calculate the direction of the new z azis

                TVector3 p1u = p1.Vect();
                p1u.SetMag(1.0);
                TVector3 p2u = p2.Vect();
                p2u.SetMag(1.0);
                TVector3 pzu = p1u - p2u;
                pzu.SetMag(1.0);
                tq.RotateUz(pzu);
                double costcs = tq.CosTheta();




                if(costcs > 0.){ 
                    nF+= 1.;} 
                else {
                    nB += 1.;}

                if(up[iqk].id % 2 == 0 || up[iqb].id % 2 == 0) //even id means u-type (unfilled will be -1)
                    n_utype++;
                else n_dtype++;


            }
        }
    }

    /* close input file */

    fclose(ifp);

    Double_t AFB = ((nF - nB))/((nF+nB));
    Double_t dAFB = (1.-AFB*AFB)/sqrt((nF+nB));
    Double_t u_frac = n_utype/(n_utype + n_dtype);

    if(correct_AFB_mbin > -1)
        //correct the predicted AFB to account for expected shift from
        //different dilution factor
        AFB = apply_AFB_correction(AFB, u_frac, correct_AFB_mbin, print);

    if(print){
        printf( "A_FB count = %.3f +- %.3f\n" 
                "u-type frac is %.3f \n"
                "%i events failed to id \n",
                AFB, dAFB, u_frac, nFail);

        printf("Selected  %d out of %i events\n", nevent, nTotal);
        printf("\n");
    }



    return AFB;
} 

