//! \file analyze_LHE
//!
//! Code to read and analyze LHE files generated by Powheg/MadGraph
//! Fit for longitudinal polarization and FB asymmetry of lplm events
//! Do q-qbar and q-gluon cases


#define STAND_ALONE

#include "compute_AFB.C"
#include "../utils/HistUtils.C"

// Global definitions 

struct particle {         //!< individual particle structure
    int id;                 //! pdg particle id
    int status;             //! decay status
    int mother[2];          //! particle mother indices
    int color[2];           //!< color info
    double p[5];            //! 4-vector + mass
    float vtime;            //! lifetime
    float spin;             //! spin (helicity) info
} ;

Double_t get_AFB(char  infile[120], double m_low, double m_high, int correct_AFB_mbin = -1, bool print = false);
Double_t get_AFB(int Zp_mass, Double_t cpl, int m_bin, bool correct_AFB = false, bool print = false);

Double_t apply_AFB_correction(Double_t AFB, Double_t u_frac, int m_bin, bool print=false){
    //slopes and intercepts from fits (As a function of uquark frac
    Double_t m[6] = {0.296, 0.299, 0.341, 0.238, 0.278, 0.247};
    Double_t b[6] = {0.766, 0.764, 0.725, 0.807, 0.776, 0.801};
    //linear function to parameterize shift
    Double_t corr_factor = m[m_bin]*u_frac + b[m_bin];
    if(print) printf("Correcting AFB with a factor of %.2f \n", corr_factor);
    return corr_factor * AFB;
}

Double_t get_AFB(int Zp_mass, Double_t cpl, int m_bin, bool correct_AFB = false, bool print = false)
    //reweight PYTHIA samples to get AFB for given Zprime mass at a given
    //dilepton mass
{

    // Construct file name to analyze
    static char infile[80];

    //strcpy(infile, "Zprime_m200.lhe");
    Float_t m_bins[] = {150,200,   250,    350,    500,    700, 100000};
    const double m_low = m_bins[m_bin];
    const double m_high =m_bins[m_bin + 1];
    int run_num =m_bin +1;
    string base_dir("/uscms_data/d3/oamram/condor_jobs/Zp_jobs/condor_output");
    if(cpl< 0.99){
        //need to remove leading 0 in float
        unsigned int_cpl = (unsigned) 100 * (cpl + 0.005);
        sprintf(infile, (base_dir+"/Zp_M%i/Zp_events_M%i_kL.%2u_bin%i.lhe").c_str(), Zp_mass, Zp_mass, int_cpl, run_num);
    }
    //else if (cpl == 1.0){
        //sprintf(infile, (base_dir+"/Zp_M%i/Zp_events_M%i_kL%.1f_bin%i.lhe").c_str(), Zp_mass, Zp_mass, cpl, run_num);
    //}
    else sprintf(infile, (base_dir+"/Zp_M%i/Zp_M%i_kL%.2f_bin%i.lhe").c_str(), Zp_mass, Zp_mass, cpl, run_num);
    //sprintf(infile, "lhe_files/MG5_condor_files/Zp_events_M%i_bin%i.lhe", Zp_mass, run_num);
    //printf("Opening file %s \n", infile);
    //printf("M bins from %.0f to %.0f \n", m_low, m_high);

    int correct_AFB_mbin = -1; //-1 means don't do correction
    if(correct_AFB) correct_AFB_mbin = m_bin;

    return get_AFB(infile, m_low, m_high, correct_AFB_mbin, print);
}


Double_t get_AFB(char infile[120], double m_low, double m_high, int correct_AFB_mbin = -1, bool print = false){

    // Local variables 
    int i, j, k, njet=0, npflavor=0, nevent, nfit;
    int nqqb=0, ngg=0; 
    int nup, idrup; 
    float xwgtup, scalup, aqedup, aqcdup;
    double alpha;
    static char header[80], inp1[80], outfile0[80], outfile1[80], outfile2[80];
    FILE *ifp;
    particle in;

    long deltas, deltaus;
    double deltat;


    // Make sure file is available 

    ifp = fopen(infile, "r");
    if (ifp==NULL) {
        printf("can't find %s\n",infile);
        return -1.;
    }

    //TH1F *h_cost = new TH1F("h", "", 20, -1, 1);

    //  Book Histograms


    nevent=0; nfit=0;
    int event_num =0;
    int nTotal =0;
    int nFail =0;
    Double_t nF = 0, nB = 0;
    Double_t n_utype=0, n_dtype=0;

    int nQQbar =0, nQQ = 0, nQGlu = 0, nGluGlu = 0;

    // Scan throught file first for the beginning of an event record	

    while (fscanf(ifp,"%s", inp1) !=EOF) {
        if(strcmp(inp1,"<event>") == 0) {
            event_num++;


            // event found


            // read event info

            fscanf(ifp,"%d %d %f %f %f %f", &nup, &idrup, &xwgtup, &scalup, &aqedup, &aqcdup);

            // Make a vector to hold all particles for each event

            std::vector<particle> up;

            int imu_m = -1; 
            int imu_p = -1;
            int inc1 = -1;
            int inc2 = -1;

            njet = 0; npflavor = 0; nqqb = 0; ngg = 0;
            int qtype = 0; // type of quark, uct = 0 , dsb = 1

            // Now loop over all particles

            for(i=0; i<nup; ++i) {
                fscanf(ifp,"%d %d %d %d %d %d %lf %lf %lf %lf %lf %f %f", &in.id, &in.status, &in.mother[0], &in.mother[1],
                        &in.color[0], &in.color[1], &in.p[0], &in.p[1], &in.p[2], &in.p[3], &in.p[4], &in.vtime, &in.spin);	
                up.push_back(in);
            } 

            //  Do event by event analysis here	

            for(i=0; i<nup; ++i) {
                if(up[i].mother[0] == 0 && up[i].mother[1] == 0) {
                    if(inc1 == -1) inc1 = i;
                    else if(inc2 == -1) inc2 = i;
                }
                if(up[i].id == 13) {imu_m = i; continue;}
                if(up[i].id == -13) {imu_p = i; continue;}

            }
            int inc1_id = up[inc1].id;
            int inc2_id = up[inc2].id;
            float quark_dir = 0.;
            if((abs(inc1_id) <= 6 && abs(inc2) <= 6) && (inc1_id * inc2_id < 0)){ //a quark and anti quark
                //qq-bar
                if(inc1_id>0) quark_dir = up[inc1].p[2];
                else quark_dir = up[inc2].p[2];
                nQQbar++;
            }
            else if(((abs(inc1_id) <= 6) && (inc2_id == 21)) ||
                    ((abs(inc2_id) <= 6) && (inc1_id == 21))){ //qglu
                if(inc1_id == 21){
                    if(inc2_id <0) quark_dir = up[inc1].p[2];//qbar-glu, want glu dir
                    else up[inc2].p[2];//q-glu ,want q dir
                }
                else if(inc2_id == 21) {
                    if(inc1_id <0) quark_dir = up[inc2].p[2];//qbar-glu, want glu dir
                    else up[inc1].p[2];//q-glu ,want q dir
                }
                nQGlu++;
            }
            else if((abs(inc1_id) <= 6) && (abs(inc2_id) <= 6) && (inc1_id * inc2_id >0)){ //2 quarks
                nQQ++;
                continue;
            }
            else if((inc1_id == 21) && (inc2_id == 21)){ //gluglu
                nGluGlu++;
                continue;
            }
            else {
                printf("unable to determine initial state for event %i \n", event_num);
                printf("indices are %i %i \n", inc1, inc2);
                printf("printing particles \n");
                for(i=0; i<nup; i++){
                    printf("%d %d %d %d \n", up[i].id, up[i].status, up[i].mother[0], up[i].mother[1]);
                }
                nFail++;
                continue;
            }
            if(imu_m == -1 || imu_p == -1){
                printf("no mus \n");
                nFail++;
                continue;
            }

            else qtype = 1;

            TLorentzVector mu_m(up[imu_m].p[0], up[imu_m].p[1], up[imu_m].p[2], up[imu_m].p[3]);
            TLorentzVector mu_p(up[imu_p].p[0], up[imu_p].p[1], up[imu_p].p[2], up[imu_p].p[3]);

            // Create vectors for the parents
            TLorentzVector cm = mu_m + mu_p;
            nTotal++;

            //printf("M is %.0f \n", cm.M());
            if(cm.M() >= m_low && cm.M() <= m_high){
                ++nevent;


                double cost = get_cost(mu_p, mu_m, false);

                double cost_st;
                if(quark_dir < 0){
                    cost_st = -cost;
                }
                else cost_st = cost;
                //h_cost->Fill(cost_st);


                if(cost_st > 0.){ 
                    nF+= 1.;} 
                else {
                    nB += 1.;}

                if(inc1_id % 2 == 0 || inc2_id % 2 == 0) //u-type quark
                    n_utype++;
                else n_dtype++;


            }
        }
    }
    //h_cost->Draw();

    /* close input file */

    fclose(ifp);

    Double_t AFB = ((nF - nB))/((nF+nB));
    Double_t dAFB = sqrt(4.*nF*nB/pow(nF+nB, 3));
    Double_t u_frac = n_utype/(n_utype + n_dtype);

    if(correct_AFB_mbin > -1)
        //correct the predicted AFB to account for expected shift from
        //different dilution factor
        AFB = apply_AFB_correction(AFB, u_frac, correct_AFB_mbin, print);

    if(print){
        printf( "A_FB count = %.3f +- %.3f\n" 
                "u-type frac is %.3f \n"
                "%i events failed to id \n",
                AFB, dAFB, u_frac, nFail);

        printf("Selected  %d out of %i events\n", nevent, nTotal);
        printf("nQQbar %i nQGlu %i nQQ %i nGluGlu %i \n", nQQbar, nQGlu, nQQ, nGluGlu);
        printf("\n");
    }



    return AFB;
} 

